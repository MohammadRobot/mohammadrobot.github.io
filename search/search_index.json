{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<ul> <li>For full documentation visit mkdocs.org.</li> <li>Fo Markdown Basic Syntax</li> </ul>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"Porjects/CheckPointOne/","title":"ROS MasterClass Checkpoint 1","text":"<p>This project is for ROS MasterClass from theconstruct.ai and for the full Souuce code checkout my_rb1_robot  repositories</p>"},{"location":"Porjects/CheckPointOne/#task-1-build-rb1-urdf-replica","title":"Task 1   Build RB1 URDF Replica","text":"<ol> <li> <p>Create a new ROS package inside <code>my_rb1_robot</code> named <code>my_rb1_description</code> with <code>rospy</code>, <code>urdf</code> and <code>xacro</code> as dependencies.</p> <ul> <li><code>$ catkin_create_pkg my_rb1_description rospy urdf xacro</code></li> </ul> </li> <li> <p>Inside the package, create a <code>urdf</code> folder. Inside this folder, create a file named <code>my_rb1_robot.urdf</code>.</p> <ul> <li>$ cd my_rb1_description/</li> <li>$ mkdir urdf</li> <li>$ touch urdf/my_rb1_robot.urdf</li> </ul> </li> </ol> <p>compute the moments of inertia: </p> <p> moments of inertia</p> <p>Robot base: m =25 h=0.3 r= 0.25 * ixx =  iyy = 0.578125 * izz = 0.78125</p> <p>wheel : m=1 h=0.05 r=0.025 * ixx = iyy = 3.6459 * izz = 0.0003125</p> <p>Caster Wheel = m=1 r=0.03 * ixx = iyy = izz 0.00036</p> <ol> <li> <p>To visualize the robot</p> <ul> <li>$ mkdir launch</li> <li>$ touch launch/display.launch</li> </ul> </li> </ol> <pre><code>&lt;?xml version=\"1.0\"?&gt;\n&lt;launch&gt;\n  &lt;param name=\"my_rb1_description\" command=\"cat '$(find my_rb1_description)/urdf/my_rb1_robot.urdf'\"/&gt;\n  &lt;!-- send fake joint values --&gt;\n  &lt;node name=\"joint_state_publisher_gui\" pkg=\"joint_state_publisher_gui\" type=\"joint_state_publisher_gui\" /&gt;\n  &lt;!-- Combine joint values --&gt;\n  &lt;node name=\"robot_state_publisher\" pkg=\"robot_state_publisher\" type=\"robot_state_publisher\"/&gt;\n  &lt;!-- Show in Rviz   --&gt;\n  &lt;node name=\"rviz\" pkg=\"rviz\" type=\"rviz\" /&gt;\n&lt;/launch&gt;\n</code></pre> <p>To view the Robot in Rviz run the following commnand: - <code>$ roslaunch my_rb1_description display.launch</code> -  Change the frixed framd value in <code>Fixed Frame</code> dropdown to <code>base_footprint</code> -  change the <code>Alpha</code> value in the <code>RobotModel</code> dropdown to <code>0.5</code></p> <p>To push the code to Github run the followin comands: - <code>$ git config --global user.name \"Mohammad Alshamsi\"</code></p> <ul> <li> <p><code>$ git config --global user.email \"alshamsi.mohammad@gmail.com\"</code></p> </li> <li> <p><code>$ git status</code></p> </li> <li> <p><code>$ git add my_rb1_description/</code></p> </li> <li> <p><code>$ git commit -m \"ceate my_rb1_robot.urdf file\"</code></p> </li> <li> <p><code>$ git tag task1</code></p> </li> <li> <p>Create a new repository on GitHub <code>my_rb1_robot</code> (don\u2019t tick the \u2018CREATE README\u201d option) https://github.com/MohammadRobot/my_rb1_robot.git</p> </li> <li> <p>Generate Personal access tokens</p> </li> <li> <p><code>git remote add origin https://github.com/MohammadRobot/my_rb1_robot.git</code></p> </li> <li> <p><code>$ git branch -M main</code></p> </li> <li><code>$ git push -u origin main</code></li> </ul>"},{"location":"Porjects/CheckPointOne/#task-2-spawn-robot-in-simulation","title":"Task 2   Spawn robot in simulation","text":"<ul> <li><code>$ cd ~/catkin_ws/src/my_rb1_robot/</code></li> <li><code>$ catkin_create_pkg my_rb1_gazebo</code></li> <li><code>$ mkdir my_rb1_gazebo/launch</code></li> <li><code>$ cp /home/user/simulation_ws/src/warehouse_robot_lab/rb1_base_sim/rb1_base_gazebo/launch/empty_warehouse.launch my_rb1_gazebo/launch/</code></li> <li><code>$ touch my_rb1_gazebo/launch/my_rb1_robot_warehouse.launch</code></li> <li><code>$ mv my_rb1_gazebo/launch/empty_warehouse.launch my_rb1_gazebo/launch/my_rb1_robot_warehouse.launch</code> </li> </ul> <p>Add the follow to the my_rb1_robot_warehouse.launch</p> <pre><code>&lt;!-- Adding URF file --&gt;  \n    &lt;param name=\"robot_description\" command=\"cat '$(find my_rb1_description)/urdf/my_rb1_robot.urdf'\" /&gt;\n    &lt;arg name=\"x\" default=\"-0.3\"/&gt;\n    &lt;arg name=\"y\" default=\"-1.3\"/&gt;\n    &lt;arg name=\"z\" default=\"0.25\"/&gt;\n\n    &lt;!-- Spawn the Robot--&gt;\n    &lt;node name=\"mybot_spawn\" pkg=\"gazebo_ros\" type=\"spawn_model\" output=\"screen\"\n          args=\"-urdf -param robot_description -model my_rb1_robot -x $(arg x) -y $(arg y) -z $(arg z)\" /&gt;\n\n    &lt;!-- launch other nodes --&gt;\n    &lt;node name=\"joint_state_publisher\" pkg=\"joint_state_publisher\" type=\"joint_state_publisher\"/&gt;\n    &lt;node name=\"robot_state_publisher\" pkg=\"robot_state_publisher\" type=\"robot_state_publisher\"/&gt;\n</code></pre> <ul> <li><code>$ roslaunch my_rb1_gazebo my_rb1_robot_warehouse.launch</code></li> </ul> <p>To chage the color of the robot in Gazebo add the following to URDF file </p> <pre><code>&lt;!-- Gazebo Tags for Robot Color--&gt;\n    &lt;gazebo reference=\"base_link\"&gt;\n        &lt;material&gt;Gazebo/Black&lt;/material&gt;\n    &lt;/gazebo&gt;\n    &lt;gazebo reference=\"front_caster\"&gt;\n        &lt;material&gt;Gazebo/Grey&lt;/material&gt;\n    &lt;/gazebo&gt;\n    &lt;gazebo reference=\"back_caster\"&gt;\n        &lt;material&gt;Gazebo/Grey&lt;/material&gt;\n    &lt;/gazebo&gt;\n    &lt;gazebo reference=\"left_wheel\"&gt;\n        &lt;material&gt;Gazebo/Red&lt;/material&gt;\n    &lt;/gazebo&gt;\n    &lt;gazebo reference=\"right_wheel\"&gt;\n        &lt;material&gt;Gazebo/Red&lt;/material&gt;\n    &lt;/gazebo&gt;\n    &lt;gazebo reference=\"front_laser\"&gt;\n        &lt;material&gt;Gazebo/Blue&lt;/material&gt;\n    &lt;/gazebo&gt;\n</code></pre> <ul> <li></li> <li><code>$ git add my_rb1_description/urdf/my_rb1_robot.urdf</code></li> <li><code>$ git add my_rb1_gazebo/</code></li> <li><code>$ git commit -m \"Complete Task 2 Spawn robot in simulation\"</code></li> <li><code>$ git tag task2</code></li> <li><code>$ git push -u origin task2</code></li> <li><code>$ git push -u origin main</code></li> </ul>"},{"location":"Porjects/CheckPointOne/#task-3-add-sensor-plugins","title":"Task 3   Add sensor plugins","text":"<ul> <li>Add libgazebo_ros_diff_drive.so plugin to URDF file </li> </ul> <pre><code>    &lt;!-- Gazebo Plugin for actuators and sensors --&gt;\n    &lt;gazebo&gt;\n        &lt;plugin filename=\"libgazebo_ros_diff_drive.so\" name=\"differential_drive_controller\"&gt;\n            &lt;alwaysOn&gt;true&lt;/alwaysOn&gt;\n            &lt;updateRate&gt;20&lt;/updateRate&gt;\n            &lt;leftJoint&gt;joint_base_left_wheel&lt;/leftJoint&gt;\n            &lt;rightJoint&gt;joint_base_right_wheel&lt;/rightJoint&gt;\n            &lt;wheelSeparation&gt;0.4&lt;/wheelSeparation&gt;\n            &lt;wheelDiameter&gt;0.05&lt;/wheelDiameter&gt;\n            &lt;torque&gt;5&lt;/torque&gt;\n            &lt;commandTopic&gt;cmd_vel&lt;/commandTopic&gt;\n            &lt;odometryTopic&gt;odom&lt;/odometryTopic&gt;\n            &lt;odometryFrame&gt;odom&lt;/odometryFrame&gt;\n            &lt;robotBaseFrame&gt;base_link&lt;/robotBaseFrame&gt;\n        &lt;/plugin&gt;\n    &lt;/gazebo&gt;\n</code></pre> <ul> <li>Add llibgazebo_ros_laser.so plugin to URDF file </li> </ul> <pre><code>    &lt;!-- Gazebo Laser Scan --&gt;\n    &lt;gazebo reference=\"front_laser\"&gt;\n        &lt;sensor type=\"ray\" name=\"head_hokuyo_sensor\"&gt;\n            &lt;pose&gt;0 0 0 0 0 0&lt;/pose&gt;\n            &lt;visualize&gt;true&lt;/visualize&gt;\n            &lt;update_rate&gt;20&lt;/update_rate&gt;\n            &lt;ray&gt;\n                &lt;scan&gt;\n                    &lt;horizontal&gt;\n                        &lt;samples&gt;720&lt;/samples&gt;\n                        &lt;resolution&gt;1&lt;/resolution&gt;\n                        &lt;min_angle&gt;-1.570796&lt;/min_angle&gt;\n                        &lt;max_angle&gt;1.570796&lt;/max_angle&gt;\n                    &lt;/horizontal&gt;\n                &lt;/scan&gt;\n                &lt;range&gt;\n                    &lt;min&gt;0.20&lt;/min&gt;\n                    &lt;max&gt;10.0&lt;/max&gt;\n                    &lt;resolution&gt;0.01&lt;/resolution&gt;\n                &lt;/range&gt;\n                &lt;noise&gt;\n                    &lt;type&gt;gaussian&lt;/type&gt;\n                    &lt;mean&gt;0.0&lt;/mean&gt;\n                    &lt;stddev&gt;0.01&lt;/stddev&gt;\n                &lt;/noise&gt;\n            &lt;/ray&gt;\n            &lt;plugin name=\"gazebo_ros_head_hokuyo_controller\" filename=\"libgazebo_ros_laser.so\"&gt;\n                &lt;topicName&gt;/scan&lt;/topicName&gt;\n                &lt;frameName&gt;sensor_laser&lt;/frameName&gt;\n            &lt;/plugin&gt;\n        &lt;/sensor&gt;\n    &lt;/gazebo&gt;\n</code></pre> <ul> <li><code>$ git add my_rb1_description/urdf/my_rb1_robot.urdf</code></li> <li><code>$ git add my_rb1_gazebo/launch/my_rb1_robot_warehouse.launch</code></li> <li><code>$ git commit -m \"complete Task 3 Add sensor plugins\"</code></li> <li><code>$ git tag task3</code></li> <li><code>$ git push -u origin task3</code></li> <li> <p><code>$ git push -u origin main</code></p> </li> <li> <p><code>$ roslaunch my_rb1_gazebo my_rb1_robot_warehouse.launch</code></p> </li> <li> <p>to drive the robot run the following commnad</p> <p>``` $ rostopic pub /cmd_vel geometry_msgs/Twist \u201clinear:</p> <p>x: 0.2</p> <p>y: 0.0</p> <p>z: 0.0</p> <p>angular:</p> <p>x: 0.0</p> <p>y: 0.0</p> <p>z: 0.0\u201d <code>`` * to view laser data run</code>$ rostopic echo /scan`</p> </li> </ul>"},{"location":"Porjects/CheckPointOne/#referance","title":"Referance","text":"<ul> <li>For Git commnad check Git Cheat Sheets</li> </ul>"},{"location":"ROS/Gazebo-Sim-Basics/","title":"Gazebo Sim Basics","text":"<p>\u201cMastering Gazebo Simulator\u201d course teaches how to build robotics simulations using Gazebo and connect it to your ROS environment. This course is a must if you want to learn how to build Gazebo worlds, models or robots. You will learn the essential, follow examples and practice by using the official references of Gazebo.</p> <p>What You Will Learn</p> <p>Gazebo GUI How to build a robot for Gazebo How to connect gazebo robots to ROS How to build custom Gazebo worlds How to write plugins for gazebo worlds and models</p>"},{"location":"ROS/Gazebo-Sim-Basics/#git","title":"Git","text":"<p>GitHub</p> <p>$ git remote add origin https://github.com/MohammadRobot/robot_racetrack.git $ git branch -M main $ git push -u origin main</p> <p>Username: MohammadRobot Password: Personal access tokens generated from https://github.com/settings/tokens</p> <p>rosbag record -O race-track-rDBk5zAY.bag odm \u2013duration 60</p> <p>Unit 3:   Connect to ROS</p> <p>This unit presents concepts around creating a new world in Gazebo. You will learn to create new worlds from scratch with different models, ground, animated objects, and actors. In addition, you will learn how to use plugins and how to control worlds programmatically.</p>"},{"location":"ROS/Gazebo-Sim-Basics/#exercise-31","title":"Exercise 3.1","text":"<p><code>$ rostopic echo /gazebo/model_states</code></p> <pre><code>$ rostopic pub /gazebo/set_model_state gazebo_msgs/ModelState \"model_name: 'unit_box'\npose:\n  position:\n    x: 10.0\n    y: 20.0\n    z: 1.0\n  orientation:\n    x: 0.0\n    y: 0.0\n    z: 0.0\n    w: 0.0\ntwist:\n  linear:\n    x: 0.0\n    y: 0.0\n    z: 0.0\n  angular:\n    x: 0.0\n    y: 0.0\n    z: 0.0\nreference_frame: ''\"\n</code></pre>"},{"location":"ROS/Gazebo-Sim-Basics/#gazebo-services-","title":"Gazebo services -","text":"<p>Gazebo starts with several services available. However, most of them are complex, for example, the /gazebo/spaw_urdf_model, which is internally used when you spawn a robot in a launch file. Therefore, it is not practical to use it from the CLI.</p> <p>/gazebo/spaw_urdf_model</p> <p>/gazebo/pause_physics       pause  the simulation /gazebo/unpause_physics     unpause the simulation /gazebo/reset_simulator     will put all objects back in their initial places. /gazebo/reset_world         does the same, except it will also reset the simulation time</p> <p><code>$ rosservice call /gazebo/reset_world</code></p> <p><code>roslaunch robot_description spawn.launch</code></p> <p><code>roslaunch robot_description spawn.launch x:=6 model_name:=second_model</code></p>"},{"location":"ROS/Gazebo-Sim-Basics/#32-ros-plugin-robot-differential-driver","title":"3.2   ROS Plugin - Robot differential driver","text":"<p>You have the robot ready to move! Your next step is to connect it to ROS is to make it possible to move the robot by it publishing to a ROS topic. There is a plugin for it, the gazebo_ros_diff_drive, and it can be included in the URDF model using the Gazebo tag. This is how it goes:</p> <p>publisher.py </p> <pre><code># Do not skip line 2 \n#!/usr/bin/env python \n\nimport rospy \n# the following line depends upon the \n# type of message you are trying to publish \nfrom std_msgs.msg import String\nfrom geometry_msgs.msg import Twist\nfrom nav_msgs.msg import Odometry \n\ndef callback(data):\n    print('X: %s, Y: %s' % (data.pose.pose.position.x, data.pose.pose.position.y))\n    #print(\"callback\")\n\n\ndef subpub(): \n    # Subscribe to topic \n    sub = rospy.Subscriber('/odom', Odometry, callback)  \n    # define the actions the publisher will make \n    pub = rospy.Publisher('/cmd_vel', Twist, queue_size=10) \n    # initialize the publishing node \n    rospy.init_node('gazebo', anonymous=True) \n\n    # define how many times per second \n    # will the data be published \n    # let's say 10 times/second or 10Hz \n    rate = rospy.Rate(10) \n    # to keep publishing as long as the core is running \n    while not rospy.is_shutdown(): \n        data = Twist()\n        data.linear.x= 0.5\n        data.angular.z= 0.2\n\n        # you could simultaneously display the data \n        # on the terminal and to the log file \n        #rospy.loginfo(data) \n\n        # publish the data to the topic using publish() \n        pub.publish(data) \n\n        # keep a buffer based on the rate defined earlier \n        rate.sleep() \n\n\nif __name__ == '__main__': \n    # it is good practice to maintain \n    # a 'try'-'except' clause \n    try: \n        subpub() \n    except rospy.ROSInterruptException: \n        pass\n</code></pre> <p>It was shown the commonly used plugins for basic robots. You can check all plugins available here:</p> <pre><code>http://wiki.ros.org/gazebo_ros_pkgs\nhttps://github.com/ros-simulation/gazebo_ros_pkgs\n</code></pre>"},{"location":"ROS/Gazebo-Sim-Basics/#unit-4-build-a-world","title":"Unit 4:   Build a World","text":""},{"location":"ROS/Gazebo-Sim-Basics/#creating-gazebo-models","title":"Creating Gazebo Models","text":"<p>package and create a folder to contain your models:</p> <p>Execute</p> <p><code>cd ~/catkin_ws/src/studying_gazebo</code></p> <p><code>mkdir -p models/box_model</code></p> <p><code>cd models/box_model</code></p> <p><code>touch model.config</code></p> <p><code>touch model.sdf</code></p> <p>Do not use materials or textures in this first moment. Instead, copy and paste the content below to the model.config file. Change author and other information accordingly:</p> <p>Copy and paste</p> <pre><code>&lt;?xml version=\"1.0\"?&gt;\n\n&lt;model&gt;\n  &lt;name&gt;Box Model&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;sdf version=\"1.6\"&gt;model.sdf&lt;/sdf&gt;\n\n  &lt;author&gt;\n    &lt;name&gt;Author's name&lt;/name&gt;\n    &lt;email&gt;no-author@mail.com&lt;/email&gt;\n  &lt;/author&gt;\n\n  &lt;description&gt;\n    A simple box model\n  &lt;/description&gt;\n&lt;/model&gt;\n</code></pre> <p>And the following to the model.sdf file:</p> <pre><code>&lt;?xml version='1.0'?&gt;\n&lt;sdf version=\"1.4\"&gt;\n  &lt;model name=\"box_model\"&gt;\n    &lt;pose&gt;0 0 0.5 0 0 0&lt;/pose&gt;\n    &lt;static&gt;false&lt;/static&gt;\n    &lt;link name=\"link\"&gt;\n      &lt;inertial&gt;\n        &lt;mass&gt;1.0&lt;/mass&gt;\n        &lt;inertia&gt;\n          &lt;ixx&gt;0.083&lt;/ixx&gt;\n          &lt;ixy&gt;0.0&lt;/ixy&gt;\n          &lt;ixz&gt;0.0&lt;/ixz&gt;\n          &lt;iyy&gt;0.083&lt;/iyy&gt;\n          &lt;iyz&gt;0.0&lt;/iyz&gt;\n          &lt;izz&gt;0.083&lt;/izz&gt;\n        &lt;/inertia&gt;\n      &lt;/inertial&gt;\n      &lt;collision name=\"collision\"&gt;\n        &lt;geometry&gt;\n          &lt;box&gt;\n            &lt;size&gt;1 1 1&lt;/size&gt;\n          &lt;/box&gt;\n        &lt;/geometry&gt;\n      &lt;/collision&gt;\n      &lt;visual name=\"visual\"&gt;\n        &lt;geometry&gt;\n          &lt;box&gt;\n            &lt;size&gt;1 1 1&lt;/size&gt;\n          &lt;/box&gt;\n        &lt;/geometry&gt;\n      &lt;/visual&gt;\n    &lt;/link&gt;\n  &lt;/model&gt;\n&lt;/sdf&gt;\n</code></pre>"},{"location":"ROS/Gazebo-Sim-Basics/#unit-5-write-gazebo-plugins","title":"Unit 5:   Write Gazebo Plugins","text":"<p>World Plugin</p> <ul> <li>Exercise 5.2.1. -</li> </ul> <p>Create a new plugin called world_plugin.</p> <ol> <li> <p>Create the file world_plugin.cc</p> <p>$ cd ~/catkin_ws $ catkin_create_pkg world_plugin gazebo gazebo_ros gazebo_plugins roscpp $ touch ~/catkin_ws/src/world_plugin/src/my_gazebo_world_plugin.cc   ```   #include    #include    namespace gazebo {   class MyGazeboPlugin : public WorldPlugin {   public: MyGazeboPlugin() : WorldPlugin() { printf(\u201cPlugin constructor method!\\n\u201d); } <p>public:     void Load(physics::WorldPtr _world, sdf::ElementPtr _sdf) {       // set a node       transport::NodePtr node(new transport::Node());       node-&gt;Init(_world-&gt;Name());</p> <pre><code>  // set publisher\n  transport::PublisherPtr publisher =\n      node-&gt;Advertise&lt;msgs::Factory&gt;(\"~/factory\");\n\n  // create msg obj\n  msgs::Factory msg;\n\n  // model to use\n  msg.set_sdf_filename(\"model://jersey_barrier\");\n\n  // setup new position\n  msgs::Set(msg.mutable_pose(),\n            ignition::math::Pose3d(ignition::math::Vector3d(5, 4, 0),\n                                  ignition::math::Quaterniond(0, 0, 0)));\n  // Send the message\n  publisher-&gt;Publish(msg);\n}\n</code></pre> <p>};</p> <p>// Register plugin   GZ_REGISTER_WORLD_PLUGIN(MyGazeboPlugin)   } // namespace gazebo   ```</p> <pre><code>$ export GAZEBO_PLUGIN_PATH=${GAZEBO_PLUGIN_PATH}:~/catkin_ws/devel/lib\n</code></pre> <p>update CMakeLists.txt</p> <pre><code>\n</code></pre> <p>cmake_minimum_required(VERSION 3.0.2) project(world_plugin)</p> <p>find_package(gazebo REQUIRED)</p> <p>find_package(catkin REQUIRED COMPONENTS   gazebo_plugins   gazebo_ros   roscpp )</p> <p>catkin_package()</p> <p>include_directories(</p>"},{"location":"ROS/Gazebo-Sim-Basics/#include","title":"include","text":"<p>${catkin_INCLUDE_DIRS} )</p> <p>include_directories(${GAZEBO_INCLUDE_DIRS}) link_directories(${GAZEBO_LIBRARY_DIRS}) list(APPEND CMAKE_CXX_FLAGS \u201c${GAZEBO_CXX_FLAGS}\u201d)</p> <p>add_library(my_gazebo_world_plugin SHARED src/my_gazebo_world_plugin.cc) target_link_libraries(my_gazebo_world_plugin ${GAZEBO_LIBRARIES})</p> <pre><code>$ cd ~/catkin_ws\n$ catkin_make\n$ source devel/setup.bash\n\n\n\n$ mkdir -p ~/catkin_ws/src/world_plugin/launch\n$ touch ~/catkin_ws/src/world_plugin/launch/gazebo.launch\n</code></pre> <p>gazebo.launch     ``    </p> <pre><code>    $ mkdir -p ~/catkin_ws/src/world_plugin/worlds\n    $ touch ~/catkin_ws/src/world_plugin/worlds/gazebo.world\n\n\ngazebo.world\n```  ```\n  &lt;?xml version=\"1.0\"?&gt;\n  &lt;sdf version=\"1.4\"&gt;\n    &lt;world name=\"default\"&gt;\n      &lt;plugin name=\"my_gazebo_world_plugin\" filename=\"libmy_gazebo_world_plugin.so\"/&gt;\n    &lt;/world&gt;\n  &lt;/sdf&gt;\n</code></pre> <ol> <li>Add the necessary instructions in CMakeLists.txt</li> </ol> <pre><code>cmake_minimum_required(VERSION 3.0.2)\nproject(world_plugins)\n\nfind_package(gazebo REQUIRED)\n\nfind_package(catkin REQUIRED COMPONENTS\n  gazebo_plugins\n  gazebo_ros\n  roscpp\n)\n\ncatkin_package()\n\ninclude_directories(\n# include\n  ${catkin_INCLUDE_DIRS}\n)\n\ninclude_directories(${GAZEBO_INCLUDE_DIRS})\nlink_directories(${GAZEBO_LIBRARY_DIRS})\nlist(APPEND CMAKE_CXX_FLAGS \"${GAZEBO_CXX_FLAGS}\")\n\nadd_library(my_gazebo_world_plugin SHARED src/my_gazebo_world_plugin.cc)\ntarget_link_libraries(my_gazebo_world_plugin ${GAZEBO_LIBRARIES})\n</code></pre> <pre><code>$ roslaunch world_plugin gazebo.launch\n</code></pre>"},{"location":"ROS/Gazebo-Sim-Basics/#-exercise-531-","title":"- Exercise 5.3.1 -","text":"<pre><code>touch ~/catkin_ws/src/writing_plugins/worlds/model.world\n\ntouch ~/catkin_ws/src/writing_plugins/src/a_model_plugin.cc\n\n\nroslaunch writing_plugins gazebo.launch\n</code></pre>"},{"location":"ROS/ROS-2-Basic/","title":"ROS 2","text":"<p>ROS 2 (Robot Operating System 2) is an open source software development kit for robotics applications. The purpose of ROS 2 is to offer a standard software platform to developers across industries that will carry them from research and prototyping through to deployment and production. ROS 2 builds on the success of ROS 1, which is used today in myriad robotics applications around the world</p>"},{"location":"ROS/ROS-2-Basic/#simulation","title":"Simulation","text":"<p>craete an accont on : https://www.theconstruct.ai</p> <p>Open the Rosjects: https://app.theconstruct.ai/l/6400c71b</p> <p>To conrol the robot by Keyboard run the following command </p> <pre><code>ros2 run teleop_twist_keyboard teleop_twist_keyboard\n</code></pre>"},{"location":"ROS/ROS-2-Basic/#ros-2-package","title":"ROS 2 package","text":"<p>ROS2 uses packages to organize its programs. Think of a package as all the files that a specific ROS program contains; all its CPP files, Python files, configuration files, compilation files, launch files, and parameter files. Also, organizing your ROS2 programs in packages makes sharing them with other developers/users much easier.</p> <p>Every package will have the following structure of files and folders:</p> <ul> <li>launch folder: Contains launch files</li> <li>src folder: Contains source files (CPP, Python)</li> <li>CMakeLists.txt: List of Cmake rules for compilation</li> <li>package.xml: Package metadata and dependencies</li> </ul>"},{"location":"ROS/ROS-2-Basic/#create-a-package","title":"Create a Package","text":"<p>Go to ROS2 Workspace:</p> <pre><code>cd ~/ros2_ws/src\n</code></pre> <p>Create Package by runing this command:</p> <pre><code>ros2 pkg create topic_publisher_pkg --build-type ament_cmake --dependencies rclcpp std_msgs\n</code></pre> <p>To compile the package:</p> <pre><code>cd ~/ros2_ws/\ncolcon build\n</code></pre> <p>Source setup.bash from the install folder so that ROS can find the packages in the workspace</p> <pre><code>source install/setup.bash\n</code></pre> <p>To list ROS2 Packages </p> <pre><code>ros2 pkg list\n</code></pre>"},{"location":"ROS/ROS-2-Basic/#launch-file","title":"Launch File","text":"<p>To run ROS 2 program you can use launch file the by runing the following command: </p> <pre><code>ros2 launch &lt;package_name&gt; &lt;launch_file&gt;\n</code></pre> <p>To create launch file </p> <pre><code>cd ~/ros2_ws/src/topic_publisher_pkg\nmkdir launch\ntouch simple_topic_publisher.launch.py\nchmod +x simple_topic_publisher.launch.py\n</code></pre> <p>Sample code of launch file</p> <pre><code>from launch import LaunchDescription\nfrom launch_ros.actions import Node\n\ndef generate_launch_description():\n    return LaunchDescription([\n        Node(\n            package='topic_publisher_pkg',\n            executable='simple_publisher_node',\n            output='screen'),\n    ])\n</code></pre>"},{"location":"ROS/ROS-2-Basic/#source-file-src","title":"Source File (src)","text":"<p>Create a C++ file in the src directory of topic_publisher_pkg</p> <pre><code>cd ~/ros2_ws/src/topic_publisher_pkg/src\ntouh simple_topic_publisher.cpp\n</code></pre> <p>Copy the following code: </p> <pre><code>#include \"rclcpp/rclcpp.hpp\"\n#include \"std_msgs/msg/int32.hpp\"\n#include &lt;chrono&gt;\n\nusing namespace std::chrono_literals;\n\n/* This example creates a subclass of Node and uses std::bind() to register a\n * member function as a callback from the timer. */\n\nclass SimplePublisher : public rclcpp::Node\n{\npublic:\n  SimplePublisher()\n  : Node(\"simple_publisher\"), count_(0)\n  {\n    publisher_ = this-&gt;create_publisher&lt;std_msgs::msg::Int32&gt;(\"counter\", 10);\n    timer_ = this-&gt;create_wall_timer(\n      500ms, std::bind(&amp;SimplePublisher::timer_callback, this));\n  }\n\nprivate:\n  void timer_callback()\n  {\n    auto message = std_msgs::msg::Int32();\n    message.data = count_;\n    count_++;\n    publisher_-&gt;publish(message);\n  }\n  rclcpp::TimerBase::SharedPtr timer_;\n  rclcpp::Publisher&lt;std_msgs::msg::Int32&gt;::SharedPtr publisher_;\n  size_t count_;\n};\n\nint main(int argc, char * argv[])\n{\n  rclcpp::init(argc, argv);\n  rclcpp::spin(std::make_shared&lt;SimplePublisher&gt;());\n  rclcpp::shutdown();\n  return 0;\n}\n</code></pre>"},{"location":"ROS/ROS-2-Basic/#cmakeliststxt-file","title":"CMakeLists.txt file","text":"<p>add the following code to  CMakeLists.txt befor <code>ament_package()</code> line</p> <pre><code>add_executable(simple_publisher_node src/simple_topic_publisher.cpp)\nament_target_dependencies(simple_publisher_node rclcpp std_msgs)\n\ninstall(TARGETS\n   simple_publisher_node\n   DESTINATION lib/${PROJECT_NAME}\n )\n\n# Install launch files.\ninstall(DIRECTORY\n  launch\n  DESTINATION share/${PROJECT_NAME}/\n)\n\n# ament_package()\n</code></pre>"},{"location":"ROS/ROS-2-Basic/#compiling-the-package","title":"Compiling the package","text":"<p>To compile the package run the following command:</p> <pre><code>cd ~/ros2_ws/\ncolcon build\nsource install/setup.bash\n</code></pre>"},{"location":"ROS/ROS-2-Basic/#visualize-data","title":"Visualize Data","text":""},{"location":"ROS/ROS-2-Basic/#rviz","title":"RVIZ","text":"<p>To open rviz run the following commmad </p> <pre><code>rviz2\n</code></pre>"},{"location":"ROS/ROS-2-Basic/#rqt_graph","title":"rqt_graph","text":"<p>To open rqt_graph  run the following commmad </p> <pre><code>rqt_graph\n</code></pre>"},{"location":"ROS/ROS-2-Basic/#referaces","title":"Referaces","text":"<ul> <li>theconstruct.ai</li> <li>docs.ros.org</li> </ul>"},{"location":"ROS/ROS-Basic/","title":"ROS","text":"<p>ROS is basically the framework that allows us to do all that we showed along this chapter. It provides the background to manage all these processes and communications between them\u2026 and much, much more!! In this tutorial you\u2019ve just scratched the surface of ROS, the basic concepts. ROS is an extremely powerful tool. If you dive into our courses you\u2019ll learn much more about ROS and you\u2019ll find yourself able to do almost anything with your robots!</p>"},{"location":"ROS/ROS-Basic/#ros-package","title":"ROS package","text":"<p>ROS uses packages to organize its programs. You can think of a package as all the files that a specific ROS program contains; all its cpp files, python files, configuration files, compilation files, launch files, and parameters files.</p> <p>All those files in the package are organized with the following structure: * launch folder: Contains launch files * src folder: Source files (cpp, python) * CMakeLists.txt: List of cmake rules for compilation * package.xml: Package information and dependencies</p> <p>To go to any ROS package, ROS gives you a command named roscd. When typing:</p> <p><code>$ roscd &lt;package_name&gt;</code></p> <p>All launch files are contained within a  tag. Inside that tag, you can see a  tag, where we specify the following parameters:"},{"location":"ROS/ROS-Basic/#create-a-package","title":"Create a package","text":"<p>When we want to create packages, we need to work in a very specific ROS workspace, which is known as the catkin workspace. The catkin workspace is the directory in your hard disk where your own ROS packages must reside in order to be usable by ROS. Usually, the catkin workspace directory is called catkin_ws.</p> <p><code>$ catkin_create_pkg &lt;package_name&gt; &lt;package_dependecies&gt;</code></p> <p>ex: <code>$ catkin_create_pkg beginner_tutorials std_msgs rospy roscpp</code></p> <ul> <li><code>$ rospack list</code>: Gives you a list with all of the packages in your ROS system.</li> <li><code>$ rospack list | grep &lt;package_name&gt;</code>: Filters, from all of the packages located in the ROS system,the package named package_name.</li> <li><code>$ roscd package_name</code>: Takes you to the location in the Hard Drive of the package, named package_name</li> </ul>"},{"location":"ROS/ROS-Basic/#compile-a-package","title":"Compile a package","text":"<ul> <li><code>$ cd ~/catkin_ws</code></li> <li><code>$ catkin_make</code></li> </ul> <p>After compiling, it\u2019s also very important to source your workspace. This will make sure that ROS will always get the latest changes done in your workspace.</p> <ul> <li><code>$ source devel/setup.bash</code></li> </ul>"},{"location":"ROS/ROS-Basic/#ros-program","title":"ROS program","text":""},{"location":"ROS/ROS-Basic/#program-file","title":"Program file","text":"<p>Create the programe file in <code>src</code> directory  * <code>$ touch src/&lt;program name&gt;.cpp</code></p>"},{"location":"ROS/ROS-Basic/#cmakelists-file","title":"CMakeLists File","text":"<p>Modify the CMakeLists.txt file in order to generate an executable from the C++ file you have just created.</p> <p>In the Build section of your CMakeLists.txt file, add the following lines:</p> <pre><code>add_executable(&lt;node_name&gt; src/&lt;program name&gt;.cpp)\nadd_dependencies(&lt;node_name&gt;  ${&lt;node_name&gt;_EXPORTED_TARGETS} ${catkin_EXPORTED_TARGETS})\ntarget_link_libraries(&lt;node_name&gt;  ${catkin_LIBRARIES})\n</code></pre> <p>Run the the following commands  * <code>$ cd ~/catkin_ws</code> * <code>$ catkin_make</code></p> <p>After compiling, it\u2019s also very important to source your workspace. This will make sure that ROS will always get the latest changes done in your workspace.</p> <ul> <li><code>$ source devel/setup.bash</code></li> </ul>"},{"location":"ROS/ROS-Basic/#launch-file","title":"Launch file","text":"<p>Create launch direcotory and launch file whicg contain the following:  * pkg=\u201dpackage_name\u201d # Name of the package that contains the code of the ROS program to execute * type=\u201dcpp_executable_name\u201d # Name of the cpp executable file that we want to execute * name=\u201dnode_name\u201d # Name of the ROS node that will launch our C++ file * output=\u201dtype_of_output\u201d # Through which channel you will print the output of the program</p> <p>To create the launch file run the followin command  * <code>$ mkdir launch</code> * <code>$ touch launch/&lt;launch name&gt;.launch</code></p> <pre><code>&lt;launch&gt;\n    &lt;!-- My Package launch file --&gt;\n    &lt;node pkg=\"&lt;package_name&gt;\" type=\"&lt;cpp_executable_name&gt;\" name=\"&lt;node_name&gt;\"  output=\"screen\"&gt;\n    &lt;/node&gt;\n&lt;/launch&gt;\n</code></pre>"},{"location":"ROS/ROS-Basic/#roscore","title":"Roscore","text":"<p>The roscore is the main process that manages all of the ROS system. You always need to have a roscore running in order to work with ROS. The command that launches a roscore is: * <code>$ roscore</code></p>"},{"location":"ROS/ROS-Basic/#rqt_graph","title":"rqt_graph","text":""},{"location":"ROS/ROS-Basic/#ros-nodes","title":"ROS Nodes","text":"<p>ROS nodes are basically programs made in ROS. The ROS command to see what nodes are actually running in a computer is:</p> <ul> <li> <p><code>$ rosnode list</code></p> </li> <li> <p><code>$ rosndoe info /&lt;node_name&gt;</code></p> </li> </ul>"},{"location":"ROS/ROS-Basic/#parameter-server","title":"Parameter Server","text":"<p>Parameter Server is a dictionary that ROS uses to store parameters. These parameters can be used by nodes at runtime and are normally used for static data, such as configuration parameters.</p> <ul> <li><code>$ rosparam list</code></li> </ul> <p>To get a value of a particular parameter, you can type:  * <code>$rosparam get &lt;parameter_name&gt;</code></p> <p>And to set a value to a parameter, you can type: * <code>$ rosparam set &lt;parameter_name&gt; &lt;value&gt;</code></p>"},{"location":"ROS/ROS-Basic/#environment-variables","title":"Environment Variables","text":"<p>ROS uses a set of Linux system environment variables in order to work properly. You can check these variables by typing:</p> <ul> <li><code>$ export | grep ROS</code></li> </ul> <p>The most important variables are the ROS_MASTER_URI and the ROS_PACKAGE_PATH.</p>"},{"location":"ROS/ROS-Basic/#rostopic","title":"rostopic","text":"<ol> <li> <p>rostopic list</p> <p>Display a list of current topics.</p> <pre><code>$ rostopic list\n</code></pre> </li> <li> <p>rostopic echo</p> <p>Display messages published to a topic.</p> <pre><code>$ rostopic echo /&lt;topic_name&gt;\n</code></pre> </li> <li> <p>To get information about a certain topic</p> <pre><code>$ rostopic info &lt;topic_name&gt;\n</code></pre> </li> <li> <p>To  publish specify message with the value you and the topic you specify.</p> <pre><code>$ rostopic pub &lt;topic_name&gt; &lt;message_type&gt; &lt;value&gt;\n</code></pre> </li> </ol> <p>For more information visit: http://wiki.ros.org/rostopic </p>"},{"location":"ROS/ROS-Basic/#messages","title":"Messages","text":"<p>ROS provides a lot of different messages. You can even create your own messages, but it is recommended to use ROS default messages when its possible.</p> <p>Messages are defined in .msg files, which are located inside a msg directory of a package.</p> <pre><code>    $ rosmsh list\n</code></pre> <p>To show one msg type </p> <pre><code>    $ rosmsg show &lt;message_name&gt;\n</code></pre>"},{"location":"ROS/ROS-Basic/#to-ceate-custom-msg","title":"To ceate custom msg","text":""},{"location":"ROS/ROS-Basic/#publisher-and-subscriber","title":"Publisher and Subscriber","text":"<p>For more information visit: http://wiki.ros.org/roscpp_tutorials/Tutorials/WritingPublisherSubscriber</p>"},{"location":"ROS/ROS-Basic/#publisher","title":"Publisher","text":"<pre><code>#include &lt;ros/ros.h&gt;\n#include &lt;std_msgs/Int32.h&gt;\n// Import all the necessary ROS libraries and import the Int32 message from the std_msgs package\n\nint main(int argc, char** argv) {\n\n    ros::init(argc, argv, \"topic_publisher\"); // Initiate a Node named 'topic_publisher'\n    ros::NodeHandle nh;\n\n    // Create a Publisher object, that willpublish on the counter topic messages of type Int32\n\n    ros::Publisher pub = nh.advertise&lt;std_msgs::Int32&gt;(\"counter\", 1000); \n    ros::Rate loop_rate(2); // Set a publish rate of 2 Hz\n\n    std_msgs::Int32 count; // Create a variable of type Int32\n    count.data = 0; // Initialize 'count' variable\n\n    while (ros::ok()) // Create a loop that will go until someone stops the program execution\n    {\n        pub.publish(count); // Publish the message within the 'count' variable\n        ros::spinOnce();\n        loop_rate.sleep(); // Make sure the publish rate maintains at 2 Hz\n        ++count.data; // Increment 'count' variable\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"ROS/ROS-Basic/#subscriber","title":"Subscriber","text":"<pre><code>#include &lt;ros/ros.h&gt;\n#include &lt;std_msgs/Int32.h&gt;\n\n// Define a function called 'callback' that receives a parameter named 'msg' \n\nvoid counterCallback(const std_msgs::Int32::ConstPtr&amp; msg) {\n  ROS_INFO(\"%d\", msg-&gt;data); // Print the value 'data' inside the 'msg' parameter\n}\n\nint main(int argc, char** argv) {\n\n    // Initiate a Node called 'topic_subscriber'\n    ros::init(argc, argv, \"topic_subscriber\"); \n    ros::NodeHandle nh;\n\n    // Create a Subscriber object that will\n    // listen to the /counter topic and will call the 'callback' function each time\n    // it reads something from the topic\n\n    ros::Subscriber sub = nh.subscribe(\"counter\", 1000, counterCallback);                                                                     \n\n    ros::spin(); // Create a loop that will keep the program in execution\n\n    return 0;\n}\n</code></pre>"},{"location":"ROS/ROS-Basic/#services","title":"Services","text":"<p>A ROS Service provides a certain functionality to your robot. A ROS Service is composed of two parts:</p> <p>Service Server: It is the one that PROVIDES the functionality. Whatever you want your Service to do, you have to place it in the Service Server.</p> <p>Service Client: It is the one that CALLS the functionality provided by the Service Server. That is, it CALLS the Service Server.</p> <p>ROS Services use a special service message, which is composed of two parts:</p> <p>Request: The request is the part of the message that is used to CALL the Service. Therefore, it is sent by the Service Client to the Service Server.</p> <p>Response: The response is the part of the message that is returned by the Service Server to the Service Client, once the Service has finished.</p> <p>ROS Services are synchronous. This means that whenever you CALL a Service Server, you have to wait until the Service has finished (and returns a response) before you can do other stuff with your robot.</p> <p>Call Serveice </p> <pre><code>$ rosservice call /the_service_name TAB-TAB\n\n$ rosservice info /name_of_the_service\n\n$ rossrv show name_of_the_package/Name_of_Service_message\n</code></pre>"},{"location":"ROS/ROS-Basic/#service-clinet","title":"Service Clinet","text":"<pre><code>#include \"ros/ros.h\"\n#include \"trajectory_by_name_srv/TrajByName.h\"\n// Import the service message used by the service /trajectory_by_name\n\nint main(int argc, char **argv)\n{\n  ros::init(argc, argv, \"service_client\"); // Initialise a ROS node with the name service_client\n  ros::NodeHandle nh;\n\n  // Create the connection to the service /trajectory_by_name\n  ros::service::waitForService(\"/trajectory_by_name\");  // wait for service to be running\n  ros::ServiceClient traj_by_name_service = nh.serviceClient&lt;trajectory_by_name_srv::TrajByName&gt;(\"/trajectory_by_name\");\n  trajectory_by_name_srv::TrajByName srv; // Create an object of type TrajByName\n  srv.request.traj_name = \"release_food\"; // Fill the variable traj_name with the desired value\n\n  if (traj_by_name_service.call(srv)) // Send through the connection the name of the trajectory to execute\n  {\n    ROS_INFO(\"%s\", srv.response.status_message.c_str()); // Print the result given by the service called\n  }\n  else\n  {\n    ROS_ERROR(\"Failed to call service /trajectory_by_name\");\n    return 1;\n  }\n\n  return 0;\n}\n</code></pre>"},{"location":"ROS/ROS-Basic/#serveice-server","title":"Serveice Server","text":"<pre><code>#include \"ros/ros.h\"\n#include \"std_srvs/Empty.h\"\n// Import the service message header file generated from the Empty.srv message\n\n// We define the callback function of the service\nbool my_callback(std_srvs::Empty::Request  &amp;req,\n                 std_srvs::Empty::Response &amp;res)\n{  \n  // res.some_variable = req.some_variable + req.other_variable;\n  ROS_INFO(\"My_callback has been called\"); // We print an string whenever the Service gets called\n  return true;\n}\n\nint main(int argc, char **argv)\n{\n  ros::init(argc, argv, \"service_server\");\n  ros::NodeHandle nh;\n\n  ros::ServiceServer my_service = nh.advertiseService(\"/my_service\", my_callback); // create the Service called                                                                                          // my_service with the defined                                                                                        // callback\n  ros::spin(); // mantain the service open.\n\n  return 0;\n}\n</code></pre>"},{"location":"ROS/ROS-Basic/#ros-commands","title":"ROS commands:","text":"<p><code>rosrun</code>: ROS command that allows you to run a ROS program without having to create a launch file to launch it (it is a different way from what we\u2019ve been doing here).</p>"},{"location":"ROS/ROS-Basic/#referaces","title":"Referaces","text":"<p>theconstruct.ai</p> <p>ROS Packages: http://wiki.ros.org/Packages</p> <p>Ros Nodes: http://wiki.ros.org/Nodes</p> <p>Parameter Server: http://wiki.ros.org/Parameter%20Server</p> <p>Roscore: http://wiki.ros.org/roscore</p> <p>ROS Environment Variables: http://wiki.ros.org/ROS/EnvironmentVariables</p>"},{"location":"ROS/scan/","title":"Scan","text":"<p>YDLidar-SDK https://github.com/YDLIDAR/YDLidar-SDK</p> <p>YDLIDAR ROS Driver https://github.com/YDLIDAR/ydlidar_ros_driver </p> <p>update X2.launch file </p> <p>cd ~/ydlidar_ws/src/ydlidar_ros_driver/launch/X2.launch</p> <pre><code>&lt;param name=\"angle_min\"    type=\"double\" value=\"-180\" /&gt;\n&lt;param name=\"angle_max\"    type=\"double\" value=\"180\" /&gt;\n\nargs=\"0.0 0.0 0.2 0.0 0.0 0.0 /laser_frame /base_footprint  40\" /&gt;\n</code></pre> <p>To follwoing:</p> <pre><code>&lt;param name=\"angle_min\"    type=\"double\" value=\"5\" /&gt;\n&lt;param name=\"angle_max\"    type=\"double\" value=\"175\" /&gt;\n\nargs=\"0.0 0.0 0.2 1.57 0.0 0.0 /laser_frame /base_footprint  40\" /&gt;\n</code></pre> <p>update ydlidar_ws/src/ydlidar_ros_driver/launch/lidar.rviz</p> <pre><code>Fixed Frame: base_footprint\n</code></pre> <p>run the code</p> <pre><code>roslaunch ydlidar_ros_driver lidar_view.launch\n\nroslaunch ydlidar_ros_driver X2.launch\n</code></pre>"},{"location":"ROS/teleop/","title":"Teleop","text":""},{"location":"ROS/teleop/#connecting-ps4-controller-to-raspberry-pi-via-bluetooth","title":"Connecting PS4 controller to Raspberry Pi via Bluetooth","text":"<p>https://salamwaddah.com/blog/connecting-ps4-controller-to-raspberry-pi-via-bluetooth</p>"},{"location":"ROS/teleop/#pairing-a-device","title":"Pairing a device","text":"<p>When using your controller on a device for the first time, you must pair it.</p> <ol> <li>Make sure the light bar on your controller is off. If the light bar is on, press and hold the PS button until it turns off. If a USB cable is connected to your controller, disconnect it.</li> <li>While pressing and holding the SHARE button, press and hold the PS button until the light bar flashes.</li> <li>Enable Bluetooth\u00ae on your device, and then select your controller from the list of Bluetooth\u00ae devices.When pairing is complete, the light bar turns a solid color. </li> </ol> <p>https://controller.dl.playstation.net/controller/lang/en/</p>"},{"location":"ROS/teleop/#test-joystic","title":"Test joystic","text":"<p>sudo apt install jstest-gtk</p> <p>start the app jstest-gtk</p>"},{"location":"ROS/teleop/#rospublisher-cmd_vel","title":"ros::Publisher  cmd_vel","text":"<p>https://github.com/ros-teleop/teleop_twist_keyboard/tree/master</p>"},{"location":"ROS/teleop/#rossubscriber-cmd_vel","title":"ros::Subscriber cmd_vel","text":"<p>referance  https://github.com/MichalDobis/osm_planner/blob/cdb1368552eb4ac6a71c85660eeaf7a220ed9582/src/navigation_example.cpp#L79 </p> <p>https://github.com/ros-teleop/teleop_twist_keyboard/tree/master</p>"},{"location":"ROS/teleop/#teleop_twist_joy","title":"teleop_twist_joy","text":"<p>http://wiki.ros.org/teleop_twist_joy</p> <pre><code>rosrun teleop_twist_joy teleop_node\n</code></pre> <p>joystick_drivers</p> <p>https://github.com/ros-drivers/joystick_drivers/tree/main</p> <pre><code>rosrun joy joy_node\n</code></pre>"}]}